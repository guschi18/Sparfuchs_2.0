# Smart Recipe Integration - Implementierungsplan

## Executive Summary

Implementierung eines Rezept-Features f√ºr SparFuchs.de, das es Nutzern erm√∂glicht:
1. **Recipe Mode Toggle** aktivieren im Chat
2. **Nat√ºrliche Anfragen** stellen (z.B. "Ich ben√∂tige zwei warme Gerichte f√ºr Montag und Dienstag. Die Gerichte sollen sehr eiwei√üreich sein und mit Reis")
3. **Rezepte mit N√§hrwerten** anzeigen (Kalorien, Protein, Fett, Kohlenhydrate)
4. **Zutaten automatisch matchen** zu aktuellen Angeboten (semantische Suche)
5. **Alle Zutaten mit einem Klick** zur Shopping-Liste hinzuf√ºgen
6. **Rezepte speichern** f√ºr sp√§ter (localStorage)

## Technische Architektur

### API-Integration: Spoonacular
- **Free Tier Start**: 150 Requests/Tag (30-50 User/Tag Kapazit√§t)
- **Upgrade-Ready**: Code vorbereitet f√ºr nahtlosen Upgrade auf Paid Tier
- **Monitoring**: Request-Counter + Logging f√ºr Upgrade-Trigger
- **Caching**: 24h Cache f√ºr Rezepte ¬í minimiert API-Calls

### Data Flow
```
User aktiviert Recipe Toggle
       |
       v
   Stellt Frage: "Zwei warme Gerichte, proteinreich, mit Reis"
       |
       v
   POST /api/chat (recipeMode: true)
       |
       v
   Spoonacular API: Recipe Search (diet=high-protein, includeIngredients=rice)
       |
       v
   F√ºr jedes Rezept: Ingredient Matching via semanticSearch()
       |
       v
   AI formatiert als RECIPE_CARD: {...}
       |
       v
   ChatMessage parst und rendert RecipeCard Komponenten
       |
       v
   User klickt "Alle Zutaten hinzuf√ºgen" oder "Rezept speichern"
```

### Neue Type Definitions

```typescript
// types/index.ts - ADDITIONS

export interface RecipeCard {
  id: string;
  title: string;
  servings: number;
  readyInMinutes: number;
  imageUrl?: string;
  sourceUrl?: string;

  nutrition: RecipeNutrition;
  ingredients: RecipeIngredient[];
  instructions: string;

  cuisines?: string[];
  diets?: string[];
}

export interface RecipeNutrition {
  calories: number;      // per serving
  protein: number;       // grams
  fat: number;
  carbs: number;
}

export interface RecipeIngredient {
  id: string;
  name: string;
  amount: number;
  unit: string;
  original: string;            // "500g chicken breast"
  matchedOffer?: ProductCard;  // Gematchtes Angebot
  isAvailable: boolean;        // true wenn matchedOffer existiert
}

export interface ChatRequest {
  message: string;
  selectedMarkets: string[];
  useSemanticSearch?: boolean;
  recipeMode?: boolean;  // ADD THIS
}

export interface SavedRecipe {
  recipe: RecipeCard;
  savedAt: number;
  lastViewedAt?: number;
  notes?: string;
}
```

## Implementierungsphasen

### Phase 1: API Setup & Integration (CRITICAL) - 2-3h

**Ziel**: Spoonacular API Client erstellen und testen

**Neue Dateien**:
- `/lib/api/spoonacular.ts` - API Client
- `/lib/api/recipe-cache.ts` - LRU Cache f√ºr Rezepte
- `/lib/api/recipe-transformer.ts` - Spoonacular ¬í RecipeCard Transformation

**Tasks**:
1. Spoonacular Account erstellen (Free Tier)
2. Environment Variable: `SPOONACULAR_API_KEY=xxx` in `.env.local`
3. API Client implementieren:
   - `searchRecipes(query, filters)` - Recipe Search
   - `getRecipeInfo(id)` - Detailed Recipe Info
   - Error Handling (Rate Limit, Timeout, API Down)
4. Cache implementieren (24h TTL, LRU eviction)
5. Request Counter + Logging f√ºr Monitoring

**Spoonacular API Client Struktur**:
```typescript
// lib/api/spoonacular.ts

export async function searchRecipes(
  query: string,
  options: {
    diet?: string;
    cuisine?: string;
    includeIngredients?: string[];
    number?: number;
  }
): Promise<RecipeCard[]> {
  // 1. Check cache
  const cacheKey = hashQuery(query, options);
  const cached = recipeCache.get(cacheKey);
  if (cached) return cached;

  // 2. Build API request
  const params = {
    query,
    number: options.number || 5,
    addRecipeInformation: true,
    addRecipeNutrition: true,
    instructionsRequired: true,
    fillIngredients: true,
    ...extractFilters(options)
  };

  // 3. API Call mit Error Handling
  const response = await fetch(
    `https://api.spoonacular.com/recipes/complexSearch?${new URLSearchParams(params)}`,
    { headers: { 'x-api-key': process.env.SPOONACULAR_API_KEY! } }
  );

  // 4. Rate Limit Check
  if (response.status === 402) {
    throw new Error('RATE_LIMIT_EXCEEDED');
  }

  // 5. Transform & Cache
  const data = await response.json();
  const recipes = data.results.map(transformSpoonacularRecipe);
  recipeCache.set(cacheKey, recipes);

  // 6. Log f√ºr Monitoring
  logApiCall('searchRecipes', { query, results: recipes.length });

  return recipes;
}
```

**Testing**:
```bash
# Test API Call
node -e "const { searchRecipes } = require('./lib/api/spoonacular'); searchRecipes('high protein chicken rice').then(console.log);"
```

---

### Phase 2: Ingredient Matching Logic (CRITICAL) - 3-4h

**Ziel**: Rezept-Zutaten zu Angeboten matchen mit semantischer Suche

**Neue Datei**:
- `/lib/data/ingredient-matcher.ts`

**Kern-Logik**:
```typescript
// lib/data/ingredient-matcher.ts

/**
 * Normalisiert Zutat f√ºr Suche
 * "fresh chicken breast" ¬í "chicken breast"
 */
export function normalizeIngredientForSearch(ingredient: RecipeIngredient): string {
  return ingredient.name
    .toLowerCase()
    .replace(/\b(fresh|organic|raw|cooked|chopped|diced|frisch|bio)\b/gi, '')
    .trim();
}

/**
 * Matched eine Zutat zu Angeboten via Semantic Search
 */
export async function matchIngredientToOffer(
  ingredient: RecipeIngredient,
  markets: string[]
): Promise<ProductCard | null> {
  const searchQuery = normalizeIngredientForSearch(ingredient);

  // Semantic Search mit TOP 1 Result
  const results = await semanticSearch(searchQuery, markets, 1);

  return results.length > 0 ? results[0] : null;
}

/**
 * Matched alle Zutaten eines Rezepts
 */
export async function matchRecipeIngredients(
  recipe: RecipeCard,
  markets: string[]
): Promise<RecipeCard> {
  // Parallel matching f√ºr Performance
  const matchedIngredients = await Promise.all(
    recipe.ingredients.map(async (ing) => {
      const matchedOffer = await matchIngredientToOffer(ing, markets);
      return {
        ...ing,
        matchedOffer: matchedOffer || undefined,
        isAvailable: !!matchedOffer
      };
    })
  );

  return {
    ...recipe,
    ingredients: matchedIngredients
  };
}
```

**Testing**:
- "chicken breast" ¬í "H√§hnchenbrust" 
- "tomatoes" ¬í "Tomaten" / "Rispentomaten" 
- "saffron" ¬í null (not available) 
- "ground beef" ¬í "Hackfleisch" 

---

### Phase 3: RecipeCard Component (HIGH) - 3-4h

**Ziel**: UI-Komponente f√ºr Rezept-Darstellung

**Neue Dateien**:
- `/app/components/Chat/RecipeCard.tsx`

**Component Struktur** (folgt ProductCard Pattern):
```typescript
// app/components/Chat/RecipeCard.tsx

interface RecipeCardProps {
  recipe: RecipeCard;
  onAddAllToList?: (ingredients: RecipeIngredient[]) => void;
  onSaveRecipe?: (recipe: RecipeCard) => void;
  isSaved?: boolean;
}

export function RecipeCard({ recipe, onAddAllToList, onSaveRecipe, isSaved }: RecipeCardProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  const handleAddAll = () => {
    const available = recipe.ingredients.filter(ing => ing.isAvailable && ing.matchedOffer);
    if (onAddAllToList) {
      onAddAllToList(available);
    }
  };

  return (
    <Card className="w-full border border-black shadow-md">
      {/* Header: Titel + Bild */}
      <CardHeader>
        {recipe.imageUrl && (
          <img src={recipe.imageUrl} alt={recipe.title} className="w-full h-48 object-cover rounded-t" />
        )}
        <h3 className="text-xl font-bold mt-2">{recipe.title}</h3>

        {/* Meta Info */}
        <div className="flex gap-2 text-sm text-gray-600 mt-1">
          <span>=e {recipe.servings} Portionen</span>
          <span>√± {recipe.readyInMinutes} Min</span>
        </div>
      </CardHeader>

      <Divider />

      {/* Nutrition Badges */}
      <CardBody>
        <div className="flex gap-2 flex-wrap mb-4">
          <Badge color="success">{recipe.nutrition.calories} kcal</Badge>
          <Badge color="primary">{recipe.nutrition.protein}g Protein</Badge>
          <Badge>{recipe.nutrition.fat}g Fett</Badge>
          <Badge>{recipe.nutrition.carbs}g Kohlenhydrate</Badge>
        </div>

        {/* Ingredients List */}
        <h4 className="font-semibold mb-2">Zutaten:</h4>
        <ul className="space-y-1">
          {recipe.ingredients.map((ing) => (
            <li key={ing.id} className="flex justify-between items-center">
              <span className="text-sm">
                {ing.amount} {ing.unit} {ing.name}
              </span>
              {ing.isAvailable ? (
                <span className="text-green-600 text-xs">
                   {ing.matchedOffer!.market} - {ing.matchedOffer!.price}¬¨
                </span>
              ) : (
                <span className="text-gray-400 text-xs">Nicht verf√ºgbar</span>
              )}
            </li>
          ))}
        </ul>

        {/* Instructions (collapsible) */}
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="mt-4 text-blue-600 text-sm"
        >
          {isExpanded ? 'Zubereitung ausblenden ¬≤' : 'Zubereitung anzeigen ¬º'}
        </button>
        {isExpanded && (
          <p className="mt-2 text-sm text-gray-700 whitespace-pre-wrap">
            {recipe.instructions}
          </p>
        )}
      </CardBody>

      <Divider />

      {/* Action Buttons */}
      <div className="flex gap-2 p-3">
        <Button
          color="primary"
          onPress={handleAddAll}
          className="flex-1"
        >
          Alle Zutaten hinzuf√ºgen ({recipe.ingredients.filter(i => i.isAvailable).length}/{recipe.ingredients.length})
        </Button>
        <Button
          color={isSaved ? "default" : "secondary"}
          onPress={() => onSaveRecipe?.(recipe)}
          isIconOnly
        >
          {isSaved ? '' : ''}
        </Button>
      </div>
    </Card>
  );
}
```

**Styling**: Folgt ProductCard Pattern mit HeroUI Components

---

### Phase 4: Recipe Toggle UI (HIGH) - 2h

**Ziel**: Toggle-Button f√ºr Recipe Mode

**Neue Datei**:
- `/app/components/UI/RecipeToggle.tsx`

**Component**:
```typescript
// app/components/UI/RecipeToggle.tsx

interface RecipeToggleProps {
  enabled: boolean;
  onChange: (enabled: boolean) => void;
}

export function RecipeToggle({ enabled, onChange }: RecipeToggleProps) {
  return (
    <div className="flex items-center gap-2 p-2 border rounded-lg">
      <span className="text-2xl"><s</span>
      <div className="flex-1">
        <h4 className="font-semibold text-sm">Rezept-Modus</h4>
        <p className="text-xs text-gray-600">Suche nach Rezepten statt Produkten</p>
      </div>
      <Switch
        isSelected={enabled}
        onValueChange={onChange}
        color="success"
      />
    </div>
  );
}
```

**Integration in page.tsx**:
```typescript
// app/page.tsx - ADD

const [recipeMode, setRecipeMode] = useState(false);

// In JSX near MarketToggles:
<RecipeToggle enabled={recipeMode} onChange={setRecipeMode} />
```

---

### Phase 5: API Route Integration (CRITICAL) - 4-5h

**Ziel**: `/api/chat/route.ts` erweitern f√ºr Recipe Mode

**Datei zu modifizieren**:
- `/app/api/chat/route.ts`

**Modifications**:

1. **Request Handling**:
```typescript
// app/api/chat/route.ts - MODIFY POST handler

export async function POST(request: NextRequest) {
  const body: ChatRequest = await request.json();
  const { message, selectedMarkets, recipeMode } = body;

  // ... validation ...

  if (recipeMode) {
    return handleRecipeMode(message, validSelectedMarkets);
  } else {
    // Existing product search logic
    // ...
  }
}
```

2. **Recipe Mode Handler**:
```typescript
// app/api/chat/route.ts - ADD NEW FUNCTION

async function handleRecipeMode(query: string, markets: string[]) {
  try {
    // 1. Search recipes via Spoonacular
    const recipes = await searchRecipes(query, {
      number: 3,
      diet: extractDiet(query),        // "high-protein" ¬í minProtein filter
      includeIngredients: extractIngredients(query)  // "rice" ¬í includeIngredients
    });

    // 2. Match ingredients to offers
    const recipesWithMatches = await Promise.all(
      recipes.map(recipe => matchRecipeIngredients(recipe, markets))
    );

    // 3. Create recipe-specific system prompt
    const systemPrompt = createRecipeSystemPrompt(markets, recipesWithMatches);

    // 4. Stream AI response (reuse existing streaming logic)
    const response = await createChatCompletion({
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: query }
      ]
    });

    return new Response(response.body, {
      headers: {
        'Content-Type': 'text/event-stream',
        ...corsHeaders
      }
    });

  } catch (error) {
    if (error.message === 'RATE_LIMIT_EXCEEDED') {
      return new Response(
        JSON.stringify({ error: 'Rezept-Limit erreicht. Bitte sp√§ter erneut versuchen.' }),
        { status: 429, headers: corsHeaders }
      );
    }
    throw error;
  }
}
```

3. **Recipe System Prompt**:
```typescript
// app/api/chat/route.ts - ADD NEW FUNCTION

function createRecipeSystemPrompt(markets: string[], recipes: RecipeCard[]): string {
  const recipesJson = JSON.stringify(recipes, null, 2);

  return `Du bist ein Koch-Assistent f√ºr SparFuchs.de.

**REZEPT-MODUS AKTIV**

**REGELN:**
1. Nutze AUSSCHLIESSLICH diese Rezeptdaten: ${recipesJson}
2. F√ºr jedes Rezept eine Zeile: RECIPE_CARD: {JSON}
3. Hebe N√§hrwerte und verf√ºgbare Zutaten hervor
4. Erkl√§re kurz, warum das Rezept zur Anfrage passt

**ANTWORTFORMAT:**
Kurze Einleitung + RECIPE_CARD Zeilen

Wenn keine passenden Rezepte: Freundlich erkl√§ren und Alternativen vorschlagen.`;
}
```

4. **Query Analysis Helpers**:
```typescript
// app/api/chat/route.ts - ADD HELPERS

function extractDiet(query: string): string | undefined {
  if (/protein|eiwei√ü/i.test(query)) return 'high-protein';
  if (/vegan/i.test(query)) return 'vegan';
  if (/vegetarisch/i.test(query)) return 'vegetarian';
  return undefined;
}

function extractIngredients(query: string): string[] {
  const ingredients = [];
  if (/reis|rice/i.test(query)) ingredients.push('rice');
  if (/h√§hnchen|chicken/i.test(query)) ingredients.push('chicken');
  if (/pasta|nudeln/i.test(query)) ingredients.push('pasta');
  return ingredients;
}
```

---

### Phase 6: ChatMessage Parsing (HIGH) - 2-3h

**Ziel**: ChatMessage Component erweitern f√ºr RECIPE_CARD Format

**Datei zu modifizieren**:
- `/app/components/Chat/ChatMessage.tsx`

**Modifications**:

1. **Add RECIPE_CARD Parsing**:
```typescript
// app/components/Chat/ChatMessage.tsx - MODIFY parseMessageContent

// ADD to parsing logic:
if (line.startsWith('RECIPE_CARD: ')) {
  try {
    const jsonString = line.substring('RECIPE_CARD: '.length);
    const recipeData: RecipeCard = JSON.parse(jsonString);
    parts.push({ type: 'recipe', data: recipeData });
  } catch (error) {
    console.error('Failed to parse RECIPE_CARD:', error);
    currentTextBuffer += line + '\n';
  }
}
```

2. **Add Recipe Rendering**:
```typescript
// app/components/Chat/ChatMessage.tsx - MODIFY render section

if (part.type === 'recipe') {
  return (
    <RecipeCard
      key={`recipe-${index}`}
      recipe={part.data}
      onAddAllToList={handleAddAllIngredientsToList}
      onSaveRecipe={handleSaveRecipe}
      isSaved={isSavedRecipe(part.data.id)}
    />
  );
}
```

3. **Add Handlers** (passed from page.tsx):
```typescript
// Props interface
interface ChatMessageProps {
  // ... existing props
  onAddAllIngredientsToList?: (ingredients: RecipeIngredient[]) => void;
  onSaveRecipe?: (recipe: RecipeCard) => void;
  isSavedRecipe?: (recipeId: string) => boolean;
}
```

---

### Phase 7: Shopping List Integration (HIGH) - 2-3h

**Ziel**: Bulk-Add Funktion f√ºr Rezept-Zutaten

**Datei zu modifizieren**:
- `/app/page.tsx`

**Implementation**:
```typescript
// app/page.tsx - ADD HANDLER

const handleAddAllIngredientsToList = useCallback((ingredients: RecipeIngredient[]) => {
  let addedCount = 0;
  let skippedCount = 0;
  let unavailableCount = 0;

  ingredients.forEach((ingredient) => {
    if (!ingredient.isAvailable || !ingredient.matchedOffer) {
      unavailableCount++;
      return;
    }

    const success = addItem(ingredient.matchedOffer);
    if (success) {
      addedCount++;
    } else {
      skippedCount++; // Already in list
    }
  });

  // Toast Notifications
  if (addedCount > 0) {
    success(`${addedCount} Zutaten zur Einkaufsliste hinzugef√ºgt!`);
  }
  if (skippedCount > 0) {
    info(`${skippedCount} Zutaten bereits in der Liste.`);
  }
  if (unavailableCount > 0) {
    warning(`${unavailableCount} Zutaten nicht in aktuellen Angeboten verf√ºgbar.`);
  }
}, [addItem, success, info, warning]);
```

---

### Phase 8: Recipe Storage (MEDIUM) - 3-4h

**Ziel**: Rezepte speichern in localStorage

**Neue Dateien**:
- `/lib/hooks/useSavedRecipes.ts`

**Modifications**:
- `/lib/utils/localStorage.ts` - Add SAVED_RECIPES key

**Implementation**:

1. **localStorage Extension**:
```typescript
// lib/utils/localStorage.ts - ADD

export const STORAGE_KEYS = {
  SHOPPING_LIST: 'sparfuchs_shopping_list',
  WISHLIST: 'sparfuchs_wishlist',
  SAVED_RECIPES: 'sparfuchs_saved_recipes',  // ADD THIS
} as const;

export const savedRecipesStorage = {
  get(): SavedRecipe[] {
    const service = getStorageService();
    return service.getItem<SavedRecipe[]>(STORAGE_KEYS.SAVED_RECIPES) || [];
  },

  set(recipes: SavedRecipe[]): boolean {
    const service = getStorageService();
    return service.setItem(STORAGE_KEYS.SAVED_RECIPES, recipes);
  },

  clear(): void {
    const service = getStorageService();
    service.removeItem(STORAGE_KEYS.SAVED_RECIPES);
  }
};
```

2. **useSavedRecipes Hook** (folgt useShoppingList Pattern):
```typescript
// lib/hooks/useSavedRecipes.ts - NEW FILE

export function useSavedRecipes() {
  const [recipes, setRecipes] = useState<SavedRecipe[]>([]);
  const [isLoaded, setIsLoaded] = useState(false);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Load on mount (SSR-safe)
  useEffect(() => {
    const stored = savedRecipesStorage.get();
    setRecipes(stored);
    setIsLoaded(true);
  }, []);

  // Debounced save
  const saveToStorage = useCallback((recipesToSave: SavedRecipe[]) => {
    if (debounceTimerRef.current) clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = setTimeout(() => {
      savedRecipesStorage.set(recipesToSave);
    }, 300);
  }, []);

  const saveRecipe = useCallback((recipe: RecipeCard): boolean => {
    const exists = recipes.some(r => r.recipe.id === recipe.id);
    if (exists) return false;

    const newRecipe: SavedRecipe = { recipe, savedAt: Date.now() };
    const newRecipes = [...recipes, newRecipe];
    setRecipes(newRecipes);
    saveToStorage(newRecipes);
    return true;
  }, [recipes, saveToStorage]);

  const removeRecipe = useCallback((recipeId: string) => {
    const filtered = recipes.filter(r => r.recipe.id !== recipeId);
    setRecipes(filtered);
    saveToStorage(filtered);
  }, [recipes, saveToStorage]);

  const isSaved = useCallback((recipeId: string): boolean => {
    return recipes.some(r => r.recipe.id === recipeId);
  }, [recipes]);

  return {
    recipes,
    recipeCount: recipes.length,
    isLoaded,
    saveRecipe,
    removeRecipe,
    clearAll: () => { setRecipes([]); savedRecipesStorage.clear(); },
    isSaved
  };
}
```

3. **Integration in page.tsx**:
```typescript
// app/page.tsx - ADD

const { recipes: savedRecipes, saveRecipe, removeRecipe, isSaved } = useSavedRecipes();

const handleSaveRecipe = useCallback((recipe: RecipeCard) => {
  if (isSaved(recipe.id)) {
    removeRecipe(recipe.id);
    info('Rezept entfernt');
  } else {
    const success = saveRecipe(recipe);
    if (success) {
      success('Rezept gespeichert!');
    }
  }
}, [saveRecipe, removeRecipe, isSaved, success, info]);
```

---

### Phase 9: Saved Recipes Panel (OPTIONAL MVP) - 3-4h

**Ziel**: UI Panel f√ºr gespeicherte Rezepte

**Neue Datei**:
- `/app/components/UI/SavedRecipesPanel.tsx`

**Implementation** (folgt WishlistPanel Pattern):
```typescript
// app/components/UI/SavedRecipesPanel.tsx

export function SavedRecipesPanel({ isOpen, onClose, recipes, onRemove }: Props) {
  return (
    <motion.div
      initial={{ x: '100%' }}
      animate={{ x: isOpen ? 0 : '100%' }}
      className="fixed right-0 top-0 h-full w-96 bg-white shadow-xl z-50"
    >
      <div className="p-4">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-bold">Gespeicherte Rezepte</h2>
          <Button isIconOnly onClick={onClose}></Button>
        </div>

        {recipes.length === 0 ? (
          <p className="text-gray-500 text-center mt-8">Keine Rezepte gespeichert</p>
        ) : (
          <div className="space-y-4">
            {recipes.map(({ recipe }) => (
              <Card key={recipe.id} className="p-3">
                <h3 className="font-semibold">{recipe.title}</h3>
                <p className="text-sm text-gray-600">
                  {recipe.servings} Portionen " {recipe.readyInMinutes} Min
                </p>
                <Button
                  size="sm"
                  color="danger"
                  onClick={() => onRemove(recipe.id)}
                  className="mt-2"
                >
                  Entfernen
                </Button>
              </Card>
            ))}
          </div>
        )}
      </div>
    </motion.div>
  );
}
```

**Note**: Dies kann auch Post-MVP implementiert werden, wenn Zeit knapp ist.

---

### Phase 10: Monitoring & Cost Control (HIGH) - 2h

**Ziel**: API-Nutzung tracken f√ºr Upgrade-Entscheidung

**Neue Datei**:
- `/lib/api/api-monitor.ts`

**Implementation**:
```typescript
// lib/api/api-monitor.ts

interface ApiStats {
  totalRequests: number;
  todayRequests: number;
  lastReset: string; // ISO date
  rateLimitHits: number;
}

const STATS_KEY = 'sparfuchs_api_stats';

export function logApiCall(endpoint: string, meta?: any) {
  if (typeof window === 'undefined') return; // Server-side only

  const stats = getStats();

  // Reset daily counter
  const today = new Date().toISOString().split('T')[0];
  if (stats.lastReset !== today) {
    stats.todayRequests = 0;
    stats.lastReset = today;
  }

  stats.totalRequests++;
  stats.todayRequests++;

  // Warning at 80% of free tier
  if (stats.todayRequests >= 120) {
    console.warn(`¬† API Limit Warning: ${stats.todayRequests}/150 requests today`);
  }

  saveStats(stats);

  // Log to console for monitoring
  console.log(`[API] ${endpoint} - Today: ${stats.todayRequests}/150`, meta);
}

export function logRateLimitHit() {
  const stats = getStats();
  stats.rateLimitHits++;
  saveStats(stats);
  console.error(`=¬® Rate Limit Hit! Total hits: ${stats.rateLimitHits}`);
}

function getStats(): ApiStats {
  try {
    const stored = localStorage.getItem(STATS_KEY);
    return stored ? JSON.parse(stored) : {
      totalRequests: 0,
      todayRequests: 0,
      lastReset: new Date().toISOString().split('T')[0],
      rateLimitHits: 0
    };
  } catch {
    return { totalRequests: 0, todayRequests: 0, lastReset: '', rateLimitHits: 0 };
  }
}

function saveStats(stats: ApiStats) {
  try {
    localStorage.setItem(STATS_KEY, JSON.stringify(stats));
  } catch (e) {
    console.error('Failed to save API stats', e);
  }
}

export function getApiStats(): ApiStats {
  return getStats();
}
```

**Usage**:
```typescript
// In spoonacular.ts after every API call:
import { logApiCall, logRateLimitHit } from './api-monitor';

if (response.status === 402) {
  logRateLimitHit();
  throw new Error('RATE_LIMIT_EXCEEDED');
}

logApiCall('searchRecipes', { query, results: recipes.length });
```

---

### Phase 11: Testing & Polish (MEDIUM) - 3-4h

**Ziel**: Feature testen und UI polieren

**Tasks**:
1. **End-to-End Testing**:
   - Recipe Mode aktivieren ¬í Rezepte suchen ¬í Zutaten hinzuf√ºgen ¬í Rezept speichern
   - Edge Cases: Keine Rezepte gefunden, alle Zutaten unavailable, Rate Limit

2. **UI Polish**:
   - Loading States (Skeleton w√§hrend Rezept-Suche)
   - Error Messages (freundlich, actionable)
   - Mobile Responsiveness (RecipeCard auf kleinen Screens)
   - Accessibility (ARIA Labels, Keyboard Navigation)

3. **Performance**:
   - Lazy Load Recipe Images
   - Memoize expensive calculations
   - Optimize re-renders

4. **Documentation**:
   - Code Comments hinzuf√ºgen
   - `/docs/features/recipe-integration.md` erstellen
   - CLAUDE.md updaten

---

## Kritische Dateien √úbersicht

### Neue Dateien (erstellen)
1. `/lib/api/spoonacular.ts` - Spoonacular API Client (~300 lines)
2. `/lib/api/recipe-cache.ts` - Recipe Caching (~100 lines)
3. `/lib/api/recipe-transformer.ts` - Data transformation (~150 lines)
4. `/lib/data/ingredient-matcher.ts` - Ingredient matching logic (~150 lines)
5. `/lib/hooks/useSavedRecipes.ts` - Recipe storage hook (~200 lines)
6. `/lib/api/api-monitor.ts` - API usage monitoring (~100 lines)
7. `/app/components/Chat/RecipeCard.tsx` - Recipe UI component (~350 lines)
8. `/app/components/UI/RecipeToggle.tsx` - Toggle component (~80 lines)
9. `/app/components/UI/SavedRecipesPanel.tsx` - Optional (~200 lines)

### Zu modifizierende Dateien
1. `/types/index.ts` - Add RecipeCard, RecipeIngredient, RecipeNutrition, SavedRecipe (+60 lines)
2. `/app/api/chat/route.ts` - Add recipe mode handling (+200 lines)
3. `/app/components/Chat/ChatMessage.tsx` - Add RECIPE_CARD parsing (+50 lines)
4. `/app/page.tsx` - Add recipe handlers and state (+80 lines)
5. `/lib/utils/localStorage.ts` - Add savedRecipesStorage (+30 lines)

## Environment Variables

```bash
# .env.local - ADD

# Spoonacular API (Free Tier: 150 req/day)
SPOONACULAR_API_KEY=your_key_here

# Feature Flags
NEXT_PUBLIC_RECIPE_MODE_ENABLED=true

# Cache Config
RECIPE_CACHE_DURATION=86400000  # 24 hours in ms
```

## Success Criteria

MVP ist erfolgreich wenn:
- [ ] Recipe Toggle funktioniert und ist sichtbar
- [ ] User kann Rezepte via Chat finden (z.B. "proteinreiche Gerichte mit Reis")
- [ ] Rezepte zeigen N√§hrwerte (Kalorien, Protein, Fett, Kohlenhydrate)
- [ ] Mind. 60% der Zutaten werden zu Angeboten gematcht
- [ ] "Alle Zutaten hinzuf√ºgen" Button funktioniert und zeigt Toast-Feedback
- [ ] Rezepte k√∂nnen gespeichert werden (localStorage)
- [ ] API Monitoring zeigt t√§gliche Request-Zahlen
- [ ] Keine kritischen Fehler in Produktion
- [ ] Response Time < 3 Sekunden (Recipe Search + Ingredient Matching)

## Risks & Mitigations

**Risk 1: API Rate Limits**
- Mitigation: 24h Caching + Monitoring + freundliche Fehlermeldung + cached Fallback

**Risk 2: Schlechtes Ingredient Matching**
- Mitigation: Niedrigerer Similarity-Threshold + manuelle Testf√§lle + User Feedback sammeln

**Risk 3: Langsame Response Zeit**
- Mitigation: Parallel API Calls + max 3 Rezepte pro Query + Aggressive Caching

**Risk 4: Hohe Kosten bei Skalierung**
- Mitigation: Start mit Free Tier + Monitoring + klarer Upgrade-Pfad bei 120 req/day

## Implementierungs-Reihenfolge (Empfohlen)

**Woche 1** (Foundation):
1. Phase 1: API Setup
2. Phase 2: Ingredient Matching
3. Phase 10: Monitoring Setup

**Woche 2** (Core Features):
4. Phase 3: RecipeCard Component
5. Phase 4: Recipe Toggle
6. Phase 5: API Route Integration

**Woche 3** (Integration):
7. Phase 6: ChatMessage Parsing
8. Phase 7: Shopping List Integration
9. Phase 8: Recipe Storage

**Woche 4** (Polish):
10. Phase 9: Saved Recipes Panel (Optional)
11. Phase 11: Testing & Polish

## Post-MVP Enhancements

- Recipe Filters (Zeit, Schwierigkeit, Di√§t)
- Wochenplan-Generator
- Recipe Collections (teilen, exportieren)
- Alternative Ingredients Vorschl√§ge
- Nutrition Tracking √ºber Zeit
- Multi-Language Support

---

## Zusammenfassung

Dieses Feature f√ºgt eine vollst√§ndige Rezept-Integration hinzu, die:
- Externe API nutzt (Spoonacular) f√ºr hochwertige Rezepte
- Semantisches Matching f√ºr Zutaten¬íAngebote verwendet
- Alle MVP-Features liefert (Suche, N√§hrwerte, Auto-Add, Speichern)
- Mit Free Tier startet und upgrade-ready ist
- Bestehende Patterns und Architektur respektiert
- Minimal-invasiv in die Codebase integriert (~1000 neue Zeilen, ~400 modifizierte Zeilen)

Gesch√§tzte Entwicklungszeit: **3-4 Wochen** (bei 20h/Woche)
