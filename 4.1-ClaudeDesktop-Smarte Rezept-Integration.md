# Feature #4: Smarte Rezept-Integration - Detaillierter Implementierungsplan

 

## üìã Executive Summary

 

**Ziel**: Nutzer k√∂nnen basierend auf aktuellen Angeboten Rezeptvorschl√§ge erhalten und Zutatenlisten automatisch in ihre Einkaufsliste √ºbertragen.

 

**Kernnutzen**:

- Inspiration: "Was kann ich mit diesen g√ºnstigen Produkten kochen?"

- Convenience: Rezeptzutaten ‚Üí Einkaufsliste in 1 Klick

- Kostenoptimierung: Rezepte basieren auf aktuellen Deals

 

**Technischer Aufwand**: Mittel (3-5 Tage)

**Business Impact**: Hoch (Differenzierung, erh√∂hte Session-Dauer)

 

---

 

## üèóÔ∏è Architektur-√úberblick

 

### Bestehende Infrastruktur (Wiederverwendung)

‚úÖ **OpenRouter AI Integration** (`lib/ai/openrouter.ts`)

‚úÖ **Streaming SSE** (`app/api/chat/route.ts`)

‚úÖ **Shopping List Hook** (`lib/hooks/useShoppingList.ts`)

‚úÖ **Product Data Types** (`types/index.ts`)

 

### Neue Komponenten (zu entwickeln)

üÜï **Recipe API Endpoint** (`app/api/recipe/route.ts`)

üÜï **Recipe Hook** (`lib/hooks/useRecipe.ts`)

üÜï **Recipe Card Component** (`app/components/Recipe/RecipeCard.tsx`)

üÜï **Recipe Mode Toggle** (Integration in MarketToggles)

üÜï **Recipe Types** (Erweiterung in `types/index.ts`)

 

---

 

## üìê Datenmodell

 

### Neue TypeScript Interfaces

 

```typescript

// types/index.ts (Erweiterung)

 

export interface Recipe {

  id: string;

  title: string;

  description: string;

  servings: number;

  prepTime: number;              // Minuten

  cookTime: number;              // Minuten

  difficulty: 'easy' | 'medium' | 'hard';

  ingredients: RecipeIngredient[];

  instructions: string[];

  nutrition?: NutritionInfo;

  matchedProducts: ProductCard[]; // Produkte aus Angeboten

  estimatedCost: number;          // Gesamtkosten basierend auf Angeboten

  sourceUrl?: string;

}

 

export interface RecipeIngredient {

  id: string;

  name: string;                   // "Butter"

  amount: number;                 // 200

  unit: string;                   // "g"

  optional: boolean;

  matchedProduct?: ProductCard;   // Zugeordnetes Angebot

}

 

export interface NutritionInfo {

  calories: number;               // pro Portion

  protein: number;                // g

  carbs: number;                  // g

  fat: number;                    // g

}

 

export interface RecipeRequest {

  products?: ProductCard[];       // Basiert auf Angeboten

  query?: string;                 // "vegetarisches Pasta-Gericht"

  selectedMarkets: string[];

  maxCost?: number;               // Budget-Filter

  servings?: number;

}

```

 

---

 

## üîß Technische Implementierung

 

### Phase 1: Backend - Recipe API Endpoint

 

**Datei**: `app/api/recipe/route.ts`

 

**Verantwortlichkeiten**:

1. Empf√§ngt RecipeRequest

2. Identifiziert passende Produkte aus Angeboten

3. Generiert Rezept via OpenRouter (Gemini 2.5 Flash)

4. Matched Zutaten mit verf√ºgbaren Produkten

5. Berechnet Gesamtkosten

6. Streamed Antwort zur√ºck

 

**Prompt-Strategie**:

```typescript

const systemPrompt = `Du bist ein kreativer Koch-Assistent f√ºr SparFuchs.de.

 

**AUFGABE**: Erstelle ein Rezept basierend auf folgenden VERF√úGBAREN ANGEBOTEN:

${JSON.stringify(matchedProducts)}

 

**REGELN**:

1. Verwende MINDESTENS 60% der Zutaten aus den verf√ºgbaren Angeboten

2. Erg√§nze nur Standard-Zutaten (Salz, Pfeffer, √ñl), die nicht in Angeboten sind

3. Ausgabeformat: JSON mit title, ingredients[], instructions[], nutrition

4. Deutsche Rezepte, ca. ${servings} Portionen

5. Schwierigkeitsgrad: ${difficulty || 'easy'}

 

**BEISPIEL-OUTPUT**:

{

  "title": "Mediterrane Gem√ºsepfanne",

  "description": "Schnelles Gericht mit saisonalem Gem√ºse",

  "servings": 4,

  "prepTime": 15,

  "cookTime": 20,

  "difficulty": "easy",

  "ingredients": [

    {"name": "Paprika", "amount": 2, "unit": "St√ºck", "optional": false},

    {"name": "Oliven√∂l", "amount": 2, "unit": "EL", "optional": false}

  ],

  "instructions": [

    "Gem√ºse waschen und schneiden",

    "In Pfanne mit √ñl anbraten"

  ],

  "nutrition": {"calories": 350, "protein": 12, "carbs": 45, "fat": 15}

}`;

```

 

**Product Matching Algorithmus**:

```typescript

function matchIngredientsToProducts(

  ingredients: RecipeIngredient[],

  availableProducts: ProductCard[]

): RecipeIngredient[] {

  return ingredients.map(ingredient => {

    // Fuzzy Matching: "Butter" ‚Üí "Deutsche Markenbutter"

    const match = availableProducts.find(p =>

      p.name.toLowerCase().includes(ingredient.name.toLowerCase()) ||

      ingredient.name.toLowerCase().includes(p.name.toLowerCase())

    );

 

    return {

      ...ingredient,

      matchedProduct: match

    };

  });

}

```

 

---

 

### Phase 2: Frontend - Recipe Hook

 

**Datei**: `lib/hooks/useRecipe.ts`

 

**API**:

```typescript

export interface UseRecipeReturn {

  recipe: Recipe | null;

  isLoading: boolean;

  error: string | null;

  generateRecipe: (request: RecipeRequest) => Promise<void>;

  addAllToShoppingList: () => void;

  addIngredientToList: (ingredientId: string) => void;

}

 

export function useRecipe(): UseRecipeReturn {

  const [recipe, setRecipe] = useState<Recipe | null>(null);

  const [isLoading, setIsLoading] = useState(false);

  const [error, setError] = useState<string | null>(null);

  const { addItem } = useShoppingList();

 

  const generateRecipe = async (request: RecipeRequest) => {

    setIsLoading(true);

    setError(null);

 

    try {

      const response = await fetch('/api/recipe', {

        method: 'POST',

        headers: { 'Content-Type': 'application/json' },

        body: JSON.stringify(request)

      });

 

      // SSE Streaming handling...

      const reader = response.body?.getReader();

      // ... (√§hnlich wie in handleSendMessage)

 

    } catch (err) {

      setError(err.message);

    } finally {

      setIsLoading(false);

    }

  };

 

  const addAllToShoppingList = () => {

    recipe?.ingredients

      .filter(i => i.matchedProduct)

      .forEach(i => addItem(i.matchedProduct!));

  };

 

  return { recipe, isLoading, error, generateRecipe, addAllToShoppingList, addIngredientToList };

}

```

 

---

 

### Phase 3: UI - Recipe Card Component

 

**Datei**: `app/components/Recipe/RecipeCard.tsx`

 

**Features**:

- Rezept-Header (Titel, Bild-Placeholder, Zeit, Portionen)

- Zutatenliste mit "Zum Warenkorb"-Buttons

- Schritt-f√ºr-Schritt Anleitung

- N√§hrwertangaben (Collapsible)

- "Alle Zutaten zur Einkaufsliste" Button

- Gesch√§tzte Gesamtkosten Badge

 

**Design-System**: Wiederverwendung bestehender Styles

- Framer Motion Animationen

- HeroUI Components (Card, Button, Badge)

- Tailwind CSS

- CSS Variables (`--sparfuchs-primary`, etc.)

 

**Responsive Layout**:

```

Mobile:     1 Spalte (Ingredients ‚Üí Instructions)

Desktop:    2 Spalten (Ingredients | Instructions)

```

 

---

 

### Phase 4: Integration in Chat Interface

 

**√Ñnderungen in `app/page.tsx`**:

 

1. **Recipe Mode State**:

```typescript

const [recipeMode, setRecipeMode] = useState(false);

```

 

2. **Toggle in MarketToggles**:

```tsx

<MarketToggles

  selectedMarkets={selectedMarkets}

  onMarketChange={handleUpdateMarkets}

  recipeMode={recipeMode}

  onRecipeModeToggle={() => setRecipeMode(!recipeMode)}

/>

```

 

3. **Conditional Routing**:

```typescript

const handleSendMessage = async (message: string) => {

  const endpoint = recipeMode ? '/api/recipe' : '/api/chat';

  // ... fetch logic

};

```

 

4. **Recipe Card Rendering**:

```tsx

{message.role === 'assistant' && message.recipe && (

  <RecipeCard

    recipe={message.recipe}

    onAddToList={handleAddToList}

    onAddAllToList={handleAddAllIngredientsToList}

  />

)}

```

 

---

 

## üß™ Testing-Strategie

 

### Unit Tests (`*.test.ts`)

 

**lib/hooks/useRecipe.test.ts**:

```typescript

describe('useRecipe', () => {

  it('should generate recipe from products', async () => {

    const { result } = renderHook(() => useRecipe());

 

    await act(async () => {

      await result.current.generateRecipe({

        products: mockProducts,

        selectedMarkets: ['Lidl', 'Aldi']

      });

    });

 

    expect(result.current.recipe).toBeTruthy();

    expect(result.current.recipe.matchedProducts.length).toBeGreaterThan(0);

  });

 

  it('should add all ingredients to shopping list', () => {

    // ...

  });

});

```

 

**app/api/recipe/route.test.ts**:

- Validierung von RecipeRequest

- Product Matching Logik

- Kostenberechnung

- Error Handling

 

### Integration Tests

 

1. **User Flow**: Search ‚Üí Recipe Mode ‚Üí Generate ‚Üí Add to List

2. **Product Matching**: Verschiedene Produktnamen (Synonyme, Varianten)

3. **Edge Cases**:

   - Keine passenden Produkte

   - Zu teure Zutaten (Budget-Filter)

   - Vegane/Vegetarische Filter

 

### Manual Testing Checklist

 

- [ ] Rezeptgenerierung aus 3-5 Produkten

- [ ] Alle Zutaten hinzuf√ºgen funktioniert

- [ ] Einzelne Zutat hinzuf√ºgen funktioniert

- [ ] Kostenberechnung korrekt

- [ ] Mobile Responsive Design

- [ ] Streaming funktioniert fl√ºssig

- [ ] Error Messages bei API-Fehlern

- [ ] Recipe Mode Toggle visuell erkennbar

 

---

 

## üìä Performance-√úberlegungen

 

### Optimierungen

 

1. **Prompt Caching**:

   - System-Prompt cachen (reduziert Input-Tokens)

   - Product-Liste nur bei √Ñnderung neu laden

 

2. **Product Matching**:

   - Fuzzy Matching mit max. 100 Produkten

   - Vorsortierung nach Relevanz (Semantic Search)

 

3. **Streaming**:

   - Rezept schrittweise anzeigen (Title ‚Üí Ingredients ‚Üí Instructions)

   - Loading Skeleton w√§hrend Streaming

 

4. **Caching**:

   - Rezepte in LocalStorage cachen (7 Tage)

   - `lib/utils/localStorage.ts` erweitern

 

### Erwartete Latenzen

 

- **API Call**: 2-4 Sekunden (Streaming start)

- **Full Recipe**: 6-10 Sekunden (complete)

- **Product Matching**: < 100ms (client-side)

 

---

 

## üöÄ Rollout-Plan

 

### Sprint 1 (Tag 1-2): Foundation

- [ ] TypeScript Interfaces (`types/index.ts`)

- [ ] Recipe API Endpoint (`app/api/recipe/route.ts`)

- [ ] Product Matching Logik

- [ ] Unit Tests f√ºr API

 

### Sprint 2 (Tag 3-4): Frontend

- [ ] `useRecipe` Hook

- [ ] RecipeCard Component (Basic)

- [ ] Integration in `page.tsx`

- [ ] Recipe Mode Toggle

 

### Sprint 3 (Tag 5): Polish & Test

- [ ] N√§hrwertangaben-Section

- [ ] Error Handling & Edge Cases

- [ ] Mobile Responsive Tweaks

- [ ] Integration Tests

- [ ] Dokumentation (`docs/app/components/Recipe/`)

 

### Post-Launch (Iteration)

- [ ] User Feedback sammeln

- [ ] A/B Testing: Recipe Mode Adoption Rate

- [ ] Erweiterung: Favoriten-Rezepte speichern

- [ ] Erweiterung: Rezept-Historie

 

---

 

## üí∞ Cost-Benefit Analyse

 

### Kosten

 

**Development**:

- 3-5 Entwicklertage (ca. 24-40 Stunden)

 

**API Kosten** (OpenRouter):

- Gemini 2.5 Flash: $0.075 / 1M Input Tokens

- Durchschnittliches Rezept: ~3000 Tokens

- Cost per Recipe: ~$0.0002 (vernachl√§ssigbar)

 

**Maintenance**:

- 2-4 Stunden/Monat (Prompt-Optimierungen)

 

### Nutzen

 

**Quantifizierbar**:

- +30% l√§ngere Session-Dauer (gesch√§tzt)

- +20% h√∂here Shopping-List-Conversion

- Unique Feature ‚Üí Marketing-Differenzierung

 

**Qualitativ**:

- H√∂here User Satisfaction

- Viraler Content (Social Sharing: "SparFuchs hat mir ein 5‚Ç¨-Rezept vorgeschlagen!")

- Daten f√ºr ML: Welche Produktkombinationen werden gesucht?

 

**ROI**: Positiv ab ~500 aktiven Nutzern/Monat

 

---

 

## üîí Sicherheit & Compliance

 

### Datenschutz

- Keine pers√∂nlichen Daten in Rezept-Requests

- LocalStorage: Nur Rezepte, keine User-IDs

- DSGVO-konform (keine Cookies f√ºr Rezepte)

 

### Content Safety

- AI Safety: Gemini Content Filters aktiv

- Rezept-Validierung: Keine gef√§hrlichen Zubereitungen

- Allergen-Warnung: "Pr√ºfe Produktinfos auf Allergene"

 

### Rate Limiting

- Max. 10 Rezept-Generierungen / User / Stunde

- Implementierung in `app/api/recipe/route.ts`

 

---

 

## üìö Dokumentation (zu erstellen)

 

### Technische Docs

- `docs/app/api/recipe/route_documentation.md`

- `docs/lib/hooks/useRecipe_documentation.md`

- `docs/app/components/Recipe/RecipeCard_documentation.md`

 

### User-Facing

- FAQ: "Wie funktionieren Rezeptvorschl√§ge?"

- Tutorial: "Von Angebot zu Rezept in 30 Sekunden"

 

---

 

## üéØ Success Metrics (KPIs)

 

### Week 1 Post-Launch

- [ ] Recipe Mode Aktivierungsrate: >15%

- [ ] Recipe ‚Üí Shopping List Conversion: >40%

- [ ] Average Recipe Generation Time: <8s

 

### Month 1

- [ ] Repeat Usage: >30% (Nutzer generieren >1 Rezept)

- [ ] User Feedback Score: >4.2/5

- [ ] Zero Critical Bugs

 

---

 

## üîÑ Zuk√ºnftige Erweiterungen (Post-MVP)

 

### V2 Features (n√§chste Iteration)

1. **Favoriten-Rezepte**: Nutzer k√∂nnen Rezepte speichern

2. **Rezept-Filter**: Vegan, Glutenfrei, Low-Carb

3. **Meal Planning**: Wochenplan aus Rezepten

4. **Community-Rezepte**: Nutzer teilen eigene Kreationen

5. **Barcode-Integration**: Produkt scannen ‚Üí Rezepte dazu

 

### API-Erweiterungen

- Integration externe Rezept-APIs (Spoonacular, Edamam)

- Image Generation (AI-generierte Rezept-Fotos)

- Voice Instructions (Text-to-Speech f√ºr Kochanleitung)

 

---

 

## ‚úÖ Review-Section

 

**Plan-Status**: ‚úÖ Initial Draft Complete

**N√§chster Schritt**: User-Approval + Sprint 1 Start

 

**Offene Fragen an Entwickler**:

1. Pr√§ferenz f√ºr Rezept-API: Nur AI oder zus√§tzlich externe API?

2. Budget f√ºr externe Rezept-Datenbanken? (Spoonacular: $150/Monat)

3. Sollen Rezepte persistent gespeichert werden (Backend-DB)?

 

**Risiken**:

- ‚ö†Ô∏è Product Matching Genauigkeit (Fuzzy-Search k√∂nnte ungenau sein)

- ‚ö†Ô∏è AI Halluzination (ung√ºltige Rezepte)

- ‚úÖ Mitigation: Strikte Prompts + Validation Layer

 

---

 

**Erstellt**: 2025-01-27

**Version**: 1.0

**N√§chstes Update**: Nach User-Feedback zu Plan